#%%
# 파이썬 메모리를 이해해보자
# 사전 지식
# 1. 파이썬은 메모리 관리를 효율적으로 하기 위해 "캐싱" 기능을 활용
# 캐싱(caching)
# - 자주 사용되는 것들을 임시로 저장해놓고 쓰는 것
# - 정수(-5 ~ 256)까지 미리 캐시에 저장됨
# 2. 컴퓨터가 파이썬 코드를 실행하는 과정
#   - 2.1 우리 코드를 "바이트 코드(이진법)" 로 변환 => 컴파일 과정
#   - 2.2 바이트 코드를 해석
#   - 2.3 바이트 코드를 실행
# 3. 컴퓨터가 파이썬 코드를 실행하는 방식
#   3.1 스크립트 모드
#       - vscode, pycharm 등 "파일을 만들어놓고" 전체를 실행하는 방식
#       - 코드 전체를 바이트 코드로 한 번에 변환
#           -> 하드 코딩된 값들 중 여러번 사용되는 것을 미리 파악 가능
#           -> 미리 파악이 가능하다 -> 캐시로 저장해놓자!
#   3.2 대화형(인터렉티브) 모드
#       - 터미널에서 python으로 실행하는 방식 or jupyter notebook
#       - 한 줄(jupyter는 셀 단위)씩 바이트 코드로 변환
#           -> 여러 번 사용되는 값들을 미리 알 수 없다.
#           -> 범용적으로 많이 쓰는 것들만 미리 캐시로 저장(-5 ~256)


# id(): 메모리 주소를 확인할 수 있는 내장 함수
# -5 ~ 256 은 a 와 b 메모리 주소가 같다.
a = 100
b = 100
print(id(a), id(b))

a = 1000
b = 1000
print(id(a), id(b)) # 실행 환경에 따라 같을 수도 있고, 다를 수도 있다.
# vscode의 경우에는 1000도 같이 나오지만
# terminal의 경우는 -5 ~ 256 까지만 같음
# - terminal 에서 python 이라 입력하면 인터프리터처럼 사용 가능
# - 종료 방법은 exit()

a = 246
b = 256
a += 10
print(id(a), id(b)) # a 와 b 주소 : 똑같다!
    # 범용적으로 많이 쓰는 -5 ~ 256은 미리 정해져있다.
    # 연산 결과가 범위 내라면 가은 주소를 쓴다!

a = 900
b = 1000
a += 100
print(id(a), id(b)) # a 와 b 주소 : 미리 예상 x, 캐싱x
                    # 주소가 다르다! 

# 문자열의 경우
# 스크립트 모드: 무조건 캐싱
# 대화형 모드: 붙어있는 알파벳, 숫자만 가능(공백을 포함한 특수문자는 캐싱 x)

# --------------------
# 리스트는 무조건 다른 주소 (캐싱이 안 된다)
a = [1]
b = [1]
print(id(a), id(b)) # 주소 다름

# 변수는 값을 복사
# 리스트는 주소를 복사하는 것
a = b
print(id(a), id(b)) # b의 주소가 a로 복사됨!


# %%

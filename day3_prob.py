#%%
# 파이썬 메모리를 이해해보자
# 사전 지식
# 1. 파이썬은 메모리 관리를 효율적으로 하기 위해 "캐싱" 기능을 활용
# 캐싱(caching)
# - 자주 사용되는 것들을 임시로 저장해놓고 쓰는 것
# - 정수(-5 ~ 256)까지 미리 캐시에 저장됨
# 2. 컴퓨터가 파이썬 코드를 실행하는 과정
#   - 2.1 우리 코드를 "바이트 코드(이진법)" 로 변환 => 컴파일 과정
#   - 2.2 바이트 코드를 해석
#   - 2.3 바이트 코드를 실행
# 3. 컴퓨터가 파이썬 코드를 실행하는 방식
#   3.1 스크립트 모드
#       - vscode, pycharm 등 "파일을 만들어놓고" 전체를 실행하는 방식
#       - 코드 전체를 바이트 코드로 한 번에 변환
#           -> 하드 코딩된 값들 중 여러번 사용되는 것을 미리 파악 가능
#           -> 미리 파악이 가능하다 -> 캐시로 저장해놓자!
#   3.2 대화형(인터렉티브) 모드
#       - 터미널에서 python으로 실행하는 방식 or jupyter notebook
#       - 한 줄(jupyter는 셀 단위)씩 바이트 코드로 변환
#           -> 여러 번 사용되는 값들을 미리 알 수 없다.
#           -> 범용적으로 많이 쓰는 것들만 미리 캐시로 저장(-5 ~256)


# id(): 메모리 주소를 확인할 수 있는 내장 함수
# -5 ~ 256 은 a 와 b 메모리 주소가 같다.
a = 100
b = 100
print(id(a), id(b))

a = 1000
b = 1000
print(id(a), id(b)) # 실행 환경에 따라 같을 수도 있고, 다를 수도 있다.
# vscode의 경우에는 1000도 같이 나오지만
# terminal의 경우는 -5 ~ 256 까지만 같음
# - terminal 에서 python 이라 입력하면 인터프리터처럼 사용 가능
# - 종료 방법은 exit()

a = 246
b = 256
a += 10
print(id(a), id(b)) # a 와 b 주소 : 똑같다!
    # 범용적으로 많이 쓰는 -5 ~ 256은 미리 정해져있다.
    # 연산 결과가 범위 내라면 가은 주소를 쓴다!

a = 900
b = 1000
a += 100
print(id(a), id(b)) # a 와 b 주소 : 미리 예상 x, 캐싱x
                    # 주소가 다르다! 

# 문자열의 경우
# 스크립트 모드: 무조건 캐싱
# 대화형 모드: 붙어있는 알파벳, 숫자만 가능(공백을 포함한 특수문자는 캐싱 x)

# --------------------
# 리스트는 무조건 다른 주소 (캐싱이 안 된다)
a = [1]
b = [1]
print(id(a), id(b)) # 주소 다름

# 변수는 값을 복사
# 리스트는 주소를 복사하는 것
a = b
print(id(a), id(b)) # b의 주소가 a로 복사됨!





# %%
# 함수 : 코드를 따로 빼냈다.
# 함수를 작성하는 목적
# 1. 재사용 : 코드를 다시 사용하기 위해
# 2. 가독성 : 기능별로 함수로 빼내면 가독성이 좋아진다.
#       -> 코드 리뷰, 리펙토링 (각자 공부해보기)
#       -> 회사에서는 (코드 리뷰, 리펙토링)을 통해 코드를 관리

# def : 예약어;keyword (함수를 정의하겠다는 키워드. define의 약어)
# 함수의 구성요소
# 1. 함수명
# 2. 파라미터(매개변수, 인자)
# 3. 내부 로직
def func(): # 함수를 "정의"했다.
    print('함수입니다') # 함수 scpoe (; 함수 영역; local) 

func() # 함수를 "호출"했다.

#%%
#기본적인 함수 요소들 예제
def func(num=10, *args, **kwargs):
    print("num: ", num)
    print("args: ", type(args), args)
    print("kwargs: ", type(kwargs), kwargs)

func(1, 2, 3, a = 4, b = 5)
#num:  1
#args:  <class 'tuple'> (2, 3)
#kwargs:  <class 'dict'> {'a': 4, 'b': 5}
func() # num에 기본값을 줘서 정상 작동함. 튜플과 딕셔너리는 빈칸으로 출력
#num:  10
#args:  <class 'tuple'> ()
#kwargs:  <class 'dict'> {}

# %%
# 계산기를 구현
# 1. 사용자가 숫자 2개를 입력
# 2. 사칙연산 4가지를 구현

#def add(a, b):
    #pass
#함수 틀만 잡고 실행하고 싶을 때 사용. 실행해도 에러가 나지 않음

# --------함수 5개로 구분
# 안내문 출력 / 사용자 숫자 2개 입력
# 전역 변수를 사용하는 방법. 가장 밖에서 입력
#num1, num2 = 0, 0
num3 = 3
def greeting():
    # 전역변수의 값을 변경시켜야 할 때는 반드시 global 키워드를 사용해야한다
    # global num1, num2

    # test: 지역 테스트에서만 사용가능한 변수
    test=10

    # num1 을 자기가 속한 스코프(greeting 함수 스코프)
    # 를 검색하니, 자기보다 나중에 선언이 되어있음
    # ->선언 전에 사용했다는 버그가 발생
    # print(num1, num2)
    print(num3)
    print('------------------------')
    print('안녕하세요! 계산기입니다!')
    print('숫자 2개를 공백으로 구분하여 입력하세요: ', end ='')
    num1, num2 = map(int, input().split())
    return num1, num2

def add(num1, num2):
    # 전역변수 가져다가 쓸 때는 global 키워드가 필요없다.
    print(f'{num1} + {num2} = {num1+num2}')

num1, num2 = greeting()
print(num1, num2)
add(num1, num2) #파라미터 정의를 해놓았으니, 전달을 해주어야 한다!

# %%
# 스코프 (평가 출제 가능성 높음)
x = 10

def outer():
    x = 20

    def inner():
        global x
        x = 30
        print("1. x:", x)

    inner()
    print("2. x:", x)

# inner() 쓰지 못하는 이유: inner 함수는 outer 함수 scope에 정의되어서
outer()
print("3. x", x)


#%%
# map
# map(함수, 시퀀스 타입)
# 시퀀스 타입 => 문자열, 리스트, ...

numbers = [1, 2, 3]

# 문제. 각 요소에 + 3을 하여라.
# 결과. [4, 5, 6]

def func(num):
    return num + 3 # map 함수는 항상 반환값이 있는 함수여야 한다.

# 원본 리스트 값을 변경시키지 않는다.
result = list(map(func, numbers))
print(numbers, result)


#%%
# 재귀 함수
# 자기 자신을 호출하는 함수

# 그냥 쓰면 무한반복!
#def func():
#    func()
# 특징. 종료 시점이 반드시 함께 구현되어야 한다.
# 재귀 함수의 장점
# 1. 어려운 문제에 대해서 코드 구현"만" 쉽다.
# 2. 큰 문제를 작은 문제로 분할해서 구현이 가능하다.
# 재귀 함수의 단점
# 1. 성능이 매우 안 좋다.
#   -> 함수 호출 시, 함수가 종료될 때까지 메모리를 차지
#   -> 공간을 계속 차지하고 있고, (공간 성능이 안 좋음)
#   -> 메모리를 차지 + 삭제 하는 시간 때문에 시간 성능도 안 좋음
#   -> 시공간 성능이 모두 안 좋음

# 재귀함수를 잘 짜려면? (재귀함수 구현 팁)
# 1. 시작점은 무조건 있다
# 2. 끝점은 무조건 있다
# 3. 나머지 구현
#   - 다음 호출 전
#   - 다음 호출
#   - 다음 호출 후

# 문제. 찍고 돌아오기
# n = 3 가정
# 시작점: 1
# 끝점: N(3)
# 다음 함수 호출 전: 현재값 출력
# 다음 함수 호출: 하나씩 증가하면서 호출
def recur(now):
    if now == 3:
        print(now, end=' ')
        return
    
    print(now, end = ' ') # 호출 전
    recur(now+1) # 호출
    print(now, end=' ') # 호출하고 돌아와서 할 것

recur(1)


#%%
# 람다 표현식